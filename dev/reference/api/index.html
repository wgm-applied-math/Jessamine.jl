<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Documentation for Jessamine</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Documentation for Jessamine</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Jessamine.jl</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/main/docs/src/reference/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractGeneOp" href="#Jessamine.AbstractGeneOp"><code>Jessamine.AbstractGeneOp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An operation to be performed as part of the function of a gene.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractGenome" href="#Jessamine.AbstractGenome"><code>Jessamine.AbstractGenome</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for genomes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractLinearModelResult" href="#Jessamine.AbstractLinearModelResult"><code>Jessamine.AbstractLinearModelResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for the results of fitting linear models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractLinearModelLayer.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractMachineSpec" href="#Jessamine.AbstractMachineSpec"><code>Jessamine.AbstractMachineSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for machine specs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractModelResult" href="#Jessamine.AbstractModelResult"><code>Jessamine.AbstractModelResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for the results of fitting a model to data.  This object can then be used for predictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L6-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractPopulationCondition" href="#Jessamine.AbstractPopulationCondition"><code>Jessamine.AbstractPopulationCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base type of conditions for a population.  These indicate whether the population is a work in progress, or why its evolution was stopped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L107-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.AbstractSolverSpec" href="#Jessamine.AbstractSolverSpec"><code>Jessamine.AbstractSolverSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base type for solver specs, used for solving for genome parameter values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L100-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Add" href="#Jessamine.Add"><code>Jessamine.Add</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Add operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Agent" href="#Jessamine.Agent"><code>Jessamine.Agent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An agent has a rating, a genome, a parameter vector, and an extra bit of data that depends on how rating is done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L79-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.BasicLinearModelResult" href="#Jessamine.BasicLinearModelResult"><code>Jessamine.BasicLinearModelResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>BasicLinearModelResult</code> has a vector of coefficients plust a bias or intercept.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractLinearModelLayer.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.DefaultSolverSpec" href="#Jessamine.DefaultSolverSpec"><code>Jessamine.DefaultSolverSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Use this if you want all default solving procedures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L105-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.EvolutionSpec" href="#Jessamine.EvolutionSpec"><code>Jessamine.EvolutionSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameters needed to run <code>random_initial_population</code> and <code>evolution_loop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L205-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.FzAnd" href="#Jessamine.FzAnd"><code>Jessamine.FzAnd</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return fuzzy AND of the operands</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.FzNand" href="#Jessamine.FzNand"><code>Jessamine.FzNand</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return fuzzy NAND of the operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.FzNor" href="#Jessamine.FzNor"><code>Jessamine.FzNor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return fuzzy NOR of the operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.FzOr" href="#Jessamine.FzOr"><code>Jessamine.FzOr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return fuzzy OR of the operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Genome" href="#Jessamine.Genome"><code>Jessamine.Genome</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A vector of blocks of instructions.  During a time step, each instruction is evaluated on the current work space.  For each <code>j</code>, the results of the instructions in block <code>j</code> are collected and added, and this sum is used as the value of slot <code>j</code> in the next work space.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L203-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.GenomeSpec" href="#Jessamine.GenomeSpec"><code>Jessamine.GenomeSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A collection of parameters specifying the genome architecture and mutation processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L19-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.LinearModelMachineSpec" href="#Jessamine.LinearModelMachineSpec"><code>Jessamine.LinearModelMachineSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrap an MLJ <code>Model</code> that uses a linear combination of input columns to produce its predictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJInside.jl#L27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.LinearModelMachineSpec-Tuple{MLJModelInterface.Model, Any, Any}" href="#Jessamine.LinearModelMachineSpec-Tuple{MLJModelInterface.Model, Any, Any}"><code>Jessamine.LinearModelMachineSpec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LinearModelMachineSpec(model::Model, lambda_parameter, lambda_operand)</code></pre><p>Construct a <code>LinearModelMachineSpec</code> using <code>model.lambda</code> for <code>lambda_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJInside.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Maximum" href="#Jessamine.Maximum"><code>Jessamine.Maximum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return the maximum of the operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Minimum" href="#Jessamine.Minimum"><code>Jessamine.Minimum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return the minimum of the operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Multiply" href="#Jessamine.Multiply"><code>Jessamine.Multiply</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiply operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.MutationDist" href="#Jessamine.MutationDist"><code>Jessamine.MutationDist</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A collection of distribution objects built from a <code>MutationSpec</code> and used to produce random numbers determining mutations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Mutation.jl#L58-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.MutationDist-Tuple{MutationSpec, Int64}" href="#Jessamine.MutationDist-Tuple{MutationSpec, Int64}"><code>Jessamine.MutationDist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MutationDist(m_spec::MutationSpec, src_index_max::Int)</code></pre><p>Use <code>m_spec</code> to build a <code>MutationDist</code>. Specify that an operand index must be &lt;= <code>src_index_max</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Mutation.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.MutationSpec" href="#Jessamine.MutationSpec"><code>Jessamine.MutationSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A collection of parameters specifying the probabilities of various mutations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Mutation.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Population" href="#Jessamine.Population"><code>Jessamine.Population</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A population is a single generation of living <code>Agent</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L154-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.RDDState" href="#Jessamine.RDDState"><code>Jessamine.RDDState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State structure corresponding to ongoing iteration of <code>RandomDuplicateDelete</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/RandomDuplicateDelete.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.RandomDuplicateDelete" href="#Jessamine.RandomDuplicateDelete"><code>Jessamine.RandomDuplicateDelete</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrap an iterator <code>source</code> to produce an iterator that will randomly include some elements yielded by the source twice in a row, and some not at all.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/RandomDuplicateDelete.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.ReciprocalAdd" href="#Jessamine.ReciprocalAdd"><code>Jessamine.ReciprocalAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Add operands and return the reciprocal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.ReciprocalMultiply" href="#Jessamine.ReciprocalMultiply"><code>Jessamine.ReciprocalMultiply</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Multiply operands and return the reciprocal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.ReciprocalSubtract" href="#Jessamine.ReciprocalSubtract"><code>Jessamine.ReciprocalSubtract</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subtract operands and return the reciprocal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.SelectionDist" href="#Jessamine.SelectionDist"><code>Jessamine.SelectionDist</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Distribution object for tournament selection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.SelectionSpec" href="#Jessamine.SelectionSpec"><code>Jessamine.SelectionSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parameters for tournament selection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.SignAdd" href="#Jessamine.SignAdd"><code>Jessamine.SignAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Return the sign of the sum of the operands</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.Subtract" href="#Jessamine.Subtract"><code>Jessamine.Subtract</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subtract LISP-style: <code>0 + x[1] - x[2] - x[3]...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.UnaryComposition" href="#Jessamine.UnaryComposition"><code>Jessamine.UnaryComposition</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Do a multi-arity operation and apply a unary operation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{Agent, Agent}" href="#Base.isless-Tuple{Agent, Agent}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(x::Agent, y::Agent)</code></pre><p>Compare the <code>rating</code> field of the two agents. This definition allows a population to be sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L99-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.area_above_curve-Tuple{Any, Any}" href="#Jessamine.area_above_curve-Tuple{Any, Any}"><code>Jessamine.area_above_curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_above_curve(y_hat, y_ref)</code></pre><p>Return the area <em>above</em> the ROC curve for the predictions <code>y_hat</code> and actual reference values <code>y_ref</code>. This is 1 minus the area under the curve. The vector <code>y_hat</code> should consist of Bernoulli distributions, as returned by a <code>LogisticClassifier</code>, for example. The vector <code>y</code> should consist of values from those distributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L207-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.describe_condition-Tuple{AbstractPopulationCondition}" href="#Jessamine.describe_condition-Tuple{AbstractPopulationCondition}"><code>Jessamine.describe_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">describe_condition(::AbstractPopulationCondition)</code></pre><p>Return a short string describing the population condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.do_simplification-Tuple{AbstractPopulationCondition}" href="#Jessamine.do_simplification-Tuple{AbstractPopulationCondition}"><code>Jessamine.do_simplification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">do_simplification(::AbstractPopulationCondition)</code></pre><p>Return whether to perform the simplification epoch. Utility function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L366-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.eval_time_step_symbolic-Tuple{GenomeSpec, Genome}" href="#Jessamine.eval_time_step_symbolic-Tuple{GenomeSpec, Genome}"><code>Jessamine.eval_time_step_symbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_time_step_symbolic(g_spec, genome; output_sym, scratch_sym, parameter_sym, input_sym)</code></pre><p>Return symbolic objects representing a single time step of <code>genome</code>. The result is a named tuple with fields <code>z</code>, <code>t</code>, <code>p</code>, <code>x</code> for the <code>Symbolics</code> objects for those variables; <code>c</code> and <code>c_next</code> for the current and future cell state in symbolic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/SymbolicForm.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.extend_if_singleton-Tuple{AbstractVector, Int64}" href="#Jessamine.extend_if_singleton-Tuple{AbstractVector, Int64}"><code>Jessamine.extend_if_singleton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend_if_singleton(v::AbstractVector, m::Int)</code></pre><p>If <code>v</code> is a singleton, as in <code>v = [x]</code>, return <code>[x, x, ...]</code>, that is, a vector of <code>m</code> copies of <code>x</code>. Otherwise, assert that <code>length(v) == m</code> and return <code>v</code>. So the result is always a vector of length <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractLinearModelLayer.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.generation_size-Tuple{SelectionSpec}" href="#Jessamine.generation_size-Tuple{SelectionSpec}"><code>Jessamine.generation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generation_size(s_spec::SelectionSpec)</code></pre><p>Return the size of a generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.genome_complexity-Tuple{AbstractMachineSpec, GenomeSpec, Genome}" href="#Jessamine.genome_complexity-Tuple{AbstractMachineSpec, GenomeSpec, Genome}"><code>Jessamine.genome_complexity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genome_complexity(mn_spec, g_spec, genome)</code></pre><p>Numerical complexity of genome.  The default implementation returns <code>mn_spec.lambda_operand</code> times the number of operands in the genome.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.genome_parameter_complexity-Tuple{AbstractMachineSpec, AbstractVector}" href="#Jessamine.genome_parameter_complexity-Tuple{AbstractMachineSpec, AbstractVector}"><code>Jessamine.genome_parameter_complexity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">genome_parameter_complexity(mn_spec, p)</code></pre><p>Numerical complexity of a parameter vector.  The default implementation returns <code>mn_spec.lambda_parameter</code> times the squared L2 norm of <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.least_squares_ridge-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector, Number, GenomeSpec, AbstractGenome, AbstractVector}" href="#Jessamine.least_squares_ridge-Tuple{AbstractVector{&lt;:AbstractVector}, AbstractVector, Number, GenomeSpec, AbstractGenome, AbstractVector}"><code>Jessamine.least_squares_ridge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">least_squares_ridge(xs, y, lambda, g_spec, genome, parameter)</code></pre><p>Compute ridge regression. Assume <code>xs</code> is an array of columns as predictors and <code>y</code> is a column of target values. Apply <code>run_genome</code> using <code>parameter</code> as the parameter vector and <code>xs</code> as the inputs. Gather a column of 1s and the output columns as a matrix <code>X</code>. The prediction values are <code>y_hat = X * b</code>, where <code>b</code> is a column of (unknown) coefficients. Solve for the <code>b</code> that minimizes <code>norm(y - y_hat)^2 + lambda * norm(b)^2</code>. If all goes well, return <code>(norm(y - y_hat), b)</code>. Otherwise return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/RidgeLayer.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.least_squares_ridge_grow_and_rate" href="#Jessamine.least_squares_ridge_grow_and_rate"><code>Jessamine.least_squares_ridge_grow_and_rate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">least_squares_ridge_grow_and_rate(xs, y, lambda_b, lambda_p, lambda_op, g_spec, genome, p_init = zeros(...))</code></pre><p>Solve for the parameter vector <code>p</code> that minimzes <code>norm(y - y_hat)^2 + lambda_b * norm(b)^2 + lambda_p * norm(p)^2 + lambda_op R</code>, where <code>y_hat</code> and <code>b</code> are found using <code>least_squares_ridge</code>. <code>R</code> is the total number of operands across all instructions in <code>genome</code>.</p><p>The solver starts with <code>p_init</code> for the initial value of <code>p</code>. If <code>p_init</code> is <code>nothing</code> or not given, a vector of zeros is used.</p><p>If all goes well, return an <code>Agent</code>, whose genome is <code>genome</code>, whose <code>parameter</code> is the best <code>p</code>, and whose <code>extra</code> is a <code>BasicLinearModelResult</code> with coefficient vector <code>b</code>.</p><p>Otherwise, return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/RidgeLayer.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_complexity-Tuple{AbstractMachineSpec, Any}" href="#Jessamine.machine_complexity-Tuple{AbstractMachineSpec, Any}"><code>Jessamine.machine_complexity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_complexity(mn_spec, m; kw_args...)</code></pre><p>Numerical complexity of a machine.</p><p>The default is to return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L45-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_complexity-Tuple{LinearModelMachineSpec, Any}" href="#Jessamine.machine_complexity-Tuple{LinearModelMachineSpec, Any}"><code>Jessamine.machine_complexity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_complexity(mn_spec, m)</code></pre><p>Numerical complexity of a machine.</p><p>Return the sum of squares of <code>MLJ.fitted_params(m)</code> multiplied by <code>mn_spec.lambda_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJInside.jl#L75-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_fit!-Tuple{AbstractMachineSpec, Any}" href="#Jessamine.machine_fit!-Tuple{AbstractMachineSpec, Any}"><code>Jessamine.machine_fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_fit!(mn_spec, m; kw_args...)</code></pre><p>The default implementation returns <code>MLJ.fit!(m; kw_args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_grow_and_rate" href="#Jessamine.machine_grow_and_rate"><code>Jessamine.machine_grow_and_rate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">machine_grow_and_rate(xs, y, g_spec, genome, mn_spec, sol_spec, w = nothing)</code></pre><p>Solve for the parameter values that produce the best machine for predicting <code>y</code> from the outputs of the <code>genome</code> applied to <code>xs</code>. A non-<code>nothing</code> value of <code>w</code> is passed to the machine as a weight vector. The resulting parameter vector is stored as the <code>parameter</code> field in the returned <code>Agent</code>.  The resulting machine is wrapped in a <code>MachineResult</code> and stored in the <code>extra</code> field of the <code>Agent</code>.</p><p>If any exception is thrown during the solving process, the exception is suppressed, and <code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L182-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_init-Tuple{AbstractMachineSpec, Any, Any}" href="#Jessamine.machine_init-Tuple{AbstractMachineSpec, Any, Any}"><code>Jessamine.machine_init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_init(mn_spec, X, y; kw_args...)</code></pre><p>Construct a machine with predictor table X and target y.</p><p>The default implementation calls <code>MLJ.machine(mn_spec.machine, X, y; kw_args...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_predict-Tuple{AbstractMachineSpec, Any, Any}" href="#Jessamine.machine_predict-Tuple{AbstractMachineSpec, Any, Any}"><code>Jessamine.machine_predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_predict(mn_spec, m, X; kw_args...)</code></pre><p>Produce a prediction <code>y_hat</code>. The default implementation returns <code>MLJ.predict(m, X; kw_args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_spec_type-Tuple{Type{MLJLinearModels.LassoRegressor}}" href="#Jessamine.machine_spec_type-Tuple{Type{MLJLinearModels.LassoRegressor}}"><code>Jessamine.machine_spec_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_spec_type(::Type{LassoRegressor})</code></pre><p>Return <code>LinearModelMachineSpec</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_spec_type-Tuple{Type{MLJLinearModels.LogisticClassifier}}" href="#Jessamine.machine_spec_type-Tuple{Type{MLJLinearModels.LogisticClassifier}}"><code>Jessamine.machine_spec_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_spec_type(::Type{LogisticClassifier})</code></pre><p>Return <code>LinearModelMachineSpec</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_spec_type-Tuple{Type{MLJLinearModels.RidgeRegressor}}" href="#Jessamine.machine_spec_type-Tuple{Type{MLJLinearModels.RidgeRegressor}}"><code>Jessamine.machine_spec_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_spec_type(::Type{RidgeRegressor})</code></pre><p>Return <code>LinearModelMachineSpec</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L272-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.machine_spec_type-Tuple{Type}" href="#Jessamine.machine_spec_type-Tuple{Type}"><code>Jessamine.machine_spec_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">machine_spec_type(t_MLJ_model::Type)::Type{&lt;:AbstractMachineSpec}</code></pre><p>Return the Jessamine type (subtype of <code>AbstractMachineSpec</code>) corresponding to the given MLJ model type. The default is to return <code>BasicModelMachineSpec</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L257-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_predict" href="#Jessamine.model_predict"><code>Jessamine.model_predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">model_predict(mr::AbstractModelResult, X; kw_args...)</code></pre><p>Given the table <code>X</code> where the columns are inputs (predictors) and the rows are points, use <code>mr</code> to predict the target value for all the points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_predict-Tuple{AbstractLinearModelResult, AbstractVector{&lt;:AbstractVector}}" href="#Jessamine.model_predict-Tuple{AbstractLinearModelResult, AbstractVector{&lt;:AbstractVector}}"><code>Jessamine.model_predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_predict(mr::AbstractLinearModelResult, xs::AbstractVector{&lt;:AbstractVector}; kw_args...)</code></pre><p>Stack the columns <code>xs</code> into a matrix <code>X</code> and call <code>model_predict</code>. The <code>kw_args</code> are splatted in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractLinearModelLayer.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_predict-Tuple{AbstractLinearModelResult, Matrix}" href="#Jessamine.model_predict-Tuple{AbstractLinearModelResult, Matrix}"><code>Jessamine.model_predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_predict(lmr::AbstractLinearModelResult, X::Matrix)</code></pre><p>Return <code>X * coefficients(lmr) + intercept(lmr)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractLinearModelLayer.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_predict-Tuple{GenomeSpec, Agent{&lt;:Number, &lt;:AbstractGenome, &lt;:AbstractVector, &lt;:AbstractModelResult}, Any}" href="#Jessamine.model_predict-Tuple{GenomeSpec, Agent{&lt;:Number, &lt;:AbstractGenome, &lt;:AbstractVector, &lt;:AbstractModelResult}, Any}"><code>Jessamine.model_predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_predict(g_spec::GenomeSpec, agent::Agent, xs; kw_args...)</code></pre><p>Run <code>agent.genome</code> on inputs <code>xs</code> and <code>agent.parameter</code>, and form the linear combination of the genome&#39;s outputs using the coefficients <code>agent.extra</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_symbolic_output-Tuple{Any, Any}" href="#Jessamine.model_symbolic_output-Tuple{Any, Any}"><code>Jessamine.model_symbolic_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_symbolic_output(g_spec, agent; kw_args...)</code></pre><p>Build a Symbolics form for the output of the final time step of running <code>agent</code>&#39;s <code>genome</code> Then use the <code>agent</code>&#39;s <code>parameter</code> vector, and feed the symbolic output of the genome as input to model result in <code>agent.extra</code> to make a prediction in symbolic form.</p><p>The <code>kw_args</code> are eventually splatted into <code>model_predict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L41-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_symbolic_output-Tuple{GenomeSpec, AbstractGenome, AbstractVector, AbstractModelResult}" href="#Jessamine.model_symbolic_output-Tuple{GenomeSpec, AbstractGenome, AbstractVector, AbstractModelResult}"><code>Jessamine.model_symbolic_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_symbolic_output(g_spec, genome, parameter, model_result; kw_args...)</code></pre><p>Build a Symbolics form for the output of the final time step of running <code>genome</code> Then use the <code>parameter</code> vector, the symbolic output of the genome, and feed the symbolic output of the genome as input to model result in <code>agent.extra</code> to make a prediction in symbolic form.</p><p>The <code>kw_args</code> are eventually splatted into <code>model_predict</code>.</p><p>Return a named tuple with lots of useful fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L58-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_symbolic_output-Tuple{NamedTuple}" href="#Jessamine.model_symbolic_output-Tuple{NamedTuple}"><code>Jessamine.model_symbolic_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_symbolic_output(fit_result::NamedTuple; kw_args...)</code></pre><p>Call <code>model_symbolic_output</code> with the <code>g_spec::GenomeSpec</code> and <code>best_agent::Agent</code> found in <code>fit_result</code>. Return the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L454-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_sympy_output-Tuple{Any, Any}" href="#Jessamine.model_sympy_output-Tuple{Any, Any}"><code>Jessamine.model_sympy_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_sympy_output(g_spec, agent; kw_args...)</code></pre><p>Build a SymPy form for the output of the final time step of running <code>agent</code>&#39;s <code>genome</code> Then use the <code>agent</code>&#39;s <code>parameter</code> vector, and feed the symbolic output of the genome as input to model result in <code>agent.extra</code> to make a prediction in symbolic form.</p><p>Key-word arguments:</p><ul><li><code>assumptions = Dict(:extended_real =&gt; true)</code>:</li></ul><p>Assumptions to use when creating symbols.</p><p>Other <code>kw_args</code> are eventually splatted into <code>model_predict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L116-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.model_sympy_output-Tuple{GenomeSpec, AbstractGenome, AbstractVector, AbstractModelResult}" href="#Jessamine.model_sympy_output-Tuple{GenomeSpec, AbstractGenome, AbstractVector, AbstractModelResult}"><code>Jessamine.model_sympy_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model_sympy_output(g_spec, genome, parameter, model_result; kw_args...)</code></pre><p>Build a SymPy form for the output of the final time step of running <code>genome</code> Then use the <code>parameter</code> vector, the symbolic output of the genome, and feed the symbolic output of the genome as input to model result in <code>agent.extra</code> to make a prediction in symbolic form.</p><p>Key-word arguments:</p><ul><li><code>assumptions = Dict(:extended_real =&gt; true)</code>:</li></ul><p>Assumptions to use when creating symbols.</p><p>Other <code>kw_args</code> are eventually splatted into <code>model_predict</code>.</p><p>Return a named tuple with lots of useful fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/AbstractModelLayer.jl#L138-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.mutate" href="#Jessamine.mutate"><code>Jessamine.mutate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutate(rng::AbstractRNG, m_dist::MutationDist, x)</code></pre><p>Randomly change <code>x</code>, using random numbers supplied by RNG and the distributions specified by <code>m_dist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Mutation.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.new_genome-Tuple{Random.AbstractRNG, SelectionDist, MutationDist, Population}" href="#Jessamine.new_genome-Tuple{Random.AbstractRNG, SelectionDist, MutationDist, Population}"><code>Jessamine.new_genome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">new_genome(rng::AbstractRNG, s_dist::SelectionDist, m_dist::MutationDist, pop::Population)</code></pre><p>Produce a new offspring genome. Pick two parents using tournament selection. Recombine their genomes, and apply mutations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L328-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.next_generation-Tuple{Random.AbstractRNG, GenomeSpec, SelectionDist, MutationDist, Population, Any}" href="#Jessamine.next_generation-Tuple{Random.AbstractRNG, GenomeSpec, SelectionDist, MutationDist, Population, Any}"><code>Jessamine.next_generation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_generation(
    rng::AbstractRNG,
    g_spec::GenomeSpec,
    s_dist::SelectionDist,
    m_dist::MutationDist,
    pop::Population,
    grow_and_rate;
    sense = MinSense)</code></pre><p>Produce the next generation of a population by selection and mutation.  The offsprings&#39; genomes are produced by <code>new_genome</code>, and fed to <code>grow_and_rate(rng, g_spec, genome)</code>, which should &quot;grow&quot; each organism and return the rating and extra data as an <code>Agent</code>, which is inserted into the population.  The <code>sense</code> parameter specifies whether selection should minimize or maximize the rating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L350-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.num_instructions-Tuple{Genome}" href="#Jessamine.num_instructions-Tuple{Genome}"><code>Jessamine.num_instructions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_instructions(genome::Genome)</code></pre><p>Return the total number of instructions in all blocks in the genome.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L225-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.num_operands-Tuple{AbstractVector}" href="#Jessamine.num_operands-Tuple{AbstractVector}"><code>Jessamine.num_operands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_operands(xs::AbstractVector)</code></pre><p>Return the total number of instruction operands in <code>xs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.num_operands-Tuple{Genome}" href="#Jessamine.num_operands-Tuple{Genome}"><code>Jessamine.num_operands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_operands(genome::Genome)</code></pre><p>Return the total number of operands in all instructions in the genome.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L234-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.num_operands-Tuple{Instruction}" href="#Jessamine.num_operands-Tuple{Instruction}"><code>Jessamine.num_operands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_operands(instruction::Instruction)</code></pre><p>Return the total number of operands in the instruction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L243-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.op_eval" href="#Jessamine.op_eval"><code>Jessamine.op_eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">op_eval(op::AbstractGeneOp, operands::AbstractVector)</code></pre><p>Return <code>op</code> applied to a list of operands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.op_eval_add_into!-Tuple{AbstractVector, AbstractGeneOp, AbstractVector}" href="#Jessamine.op_eval_add_into!-Tuple{AbstractVector, AbstractGeneOp, AbstractVector}"><code>Jessamine.op_eval_add_into!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">op_eval_add_into!(dest, op, operands)</code></pre><p>Apply the operator <code>op</code> to <code>operands</code> and add the result elementwise in place to dest.  The default is to do <code>dest .= dest .+ op_eval(op, operands)</code>.</p><p>The idea here is that in-place accumulation instead of the default implementation can sometimes avoid the allocation of a temporary array to hold the result of <code>op_eval(...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L176-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.parameter_solver_optimization_function-Tuple{AbstractSolverSpec, Any}" href="#Jessamine.parameter_solver_optimization_function-Tuple{AbstractSolverSpec, Any}"><code>Jessamine.parameter_solver_optimization_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_solver_optimization_function(sol_spec, f)</code></pre><p>Build an <code>OptimizationFunction</code> around the function <code>f(genome_parameter_vector, _)</code>. The resulting objective function object will eventually be passed to <code>solve()</code>. The default implementation returns <code>OptimizationFunction(f)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.parameter_solver_optimization_problem-Tuple{AbstractSolverSpec, GenomeSpec, Any, Any}" href="#Jessamine.parameter_solver_optimization_problem-Tuple{AbstractSolverSpec, GenomeSpec, Any, Any}"><code>Jessamine.parameter_solver_optimization_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_solver_optimization_problem(sol_spec, g_spec, optim_fn, context)</code></pre><p>Build an <code>OptimizationProblem</code> around the <code>OptimizationFunction</code>. The resulting problem object will be passed to <code>solve</code>. The default implementation returns <code>OptimizationProblem(optim_fn, zeros(...), context, sense=MinSense)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.parameter_solver_solve-Tuple{AbstractSolverSpec, Any}" href="#Jessamine.parameter_solver_solve-Tuple{AbstractSolverSpec, Any}"><code>Jessamine.parameter_solver_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_solver_solve(sol_spec, optim_prob)</code></pre><p>Solve the problem generated by <code>parameter_solver_optimization_problem()</code>. The default implementation returns <code>solve(optim_prob, NelderMeade())</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.pick_parent-Tuple{Random.AbstractRNG, SelectionDist, Population}" href="#Jessamine.pick_parent-Tuple{Random.AbstractRNG, SelectionDist, Population}"><code>Jessamine.pick_parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pick_parent(rng::AbstractRNG, s_dist::SelectionDist, pop::Population)::Agent</code></pre><p>Using tournament selection, pick a parent from the population.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.prediction_performance-Tuple{AbstractMachineSpec, AbstractVector, AbstractVector}" href="#Jessamine.prediction_performance-Tuple{AbstractMachineSpec, AbstractVector, AbstractVector}"><code>Jessamine.prediction_performance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prediction_performance(mn_spec, y_hat, y_ref)</code></pre><p>Return a performance measure of the prediction <code>y_hat</code> compared to reference <code>y_ref</code>.</p><p>The default implementation applies the callable <code>mn_spec.performance(y_hat, y_ref)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MachineLayer.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.random_genome-Tuple{Random.AbstractRNG, GenomeSpec, MutationDist, Distributions.Distribution}" href="#Jessamine.random_genome-Tuple{Random.AbstractRNG, GenomeSpec, MutationDist, Distributions.Distribution}"><code>Jessamine.random_genome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_genome(rng::AbstractRNG, g_spec::GenomeSpec, m_spec::MutationSpec, arity_dist::Distribution)</code></pre><p>Produce a random genome.  It will contain an instruction block for each mutable slot in the state array as specified by <code>g_spec</code>. Each block will contain one random instruction.  The operator is picked uniformly at random from <code>m_spec.op_inventory</code>.  The number of operands is drawn from <code>arity_dist</code>.  The operands are drawn uniformly from the set of possible indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L177-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.random_initial_population-Tuple{Random.AbstractRNG, EvolutionSpec, Distributions.Distribution}" href="#Jessamine.random_initial_population-Tuple{Random.AbstractRNG, EvolutionSpec, Distributions.Distribution}"><code>Jessamine.random_initial_population</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_initial_population(
    rng::AbstractRNG,
    e_spec::EvolutionSpec,
    arity_dist::Distribution;
    sense = MinSense)</code></pre><p>Initialize a random initial population from an <code>e_spec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L286-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.random_initial_population-Tuple{Random.AbstractRNG, GenomeSpec, MutationDist, Distributions.Distribution, SelectionSpec, Any}" href="#Jessamine.random_initial_population-Tuple{Random.AbstractRNG, GenomeSpec, MutationDist, Distributions.Distribution, SelectionSpec, Any}"><code>Jessamine.random_initial_population</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_initial_population(
    rng::AbstractRNG,
    g_spec::GenomeSpec,
    m_dist::MutationDist,
    arity_dist::Distribution,
    s_spec::SelectionSpec,
    grow_and_rate;
    sense = MinSense)::Population</code></pre><p>Make a random initial population.  The number of genomes is specified by adding the number of new genomes per generation and the number of keepers given in <code>s_spec</code>.  Other parameters are passed to <code>random_genome</code> to produce random genomes. The <code>grow_and_rate</code> function is called with <code>rng, g_spec, genome</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L246-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.replace_near_integer-Tuple{SymbolicUtils.BasicSymbolic}" href="#Jessamine.replace_near_integer-Tuple{SymbolicUtils.BasicSymbolic}"><code>Jessamine.replace_near_integer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_near_integer(expr; tolerance=1.0e-10)</code></pre><p>Round literal floating-point numbers within a symbolic expression. Specifically, if a number <code>a</code> differs <code>round(a)</code> by less thant <code>tolerance</code>, it gets replaced by <code>round(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/SymbolicForm.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.run_genome-Tuple{GenomeSpec, AbstractGenome, AbstractArray, Any}" href="#Jessamine.run_genome-Tuple{GenomeSpec, AbstractGenome, AbstractArray, Any}"><code>Jessamine.run_genome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_genome(g_spec::GenomeSpec, genome::Genome, parameter::AbstractVector, input)::Vector</code></pre><p>Build a work space vector using zeros for each output and scratch slot, followed by the <code>parameter</code> vector, then the <code>input</code> vector.  Evaluate the instructions in <code>genome</code>, repeating the evaluation <code>g_spec.num_time_steps</code>.  Return an array that contains, for each time step, the elements 1 through <code>g_spec.output_size</code> of the work space vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L375-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.run_genome_symbolic-Tuple{GenomeSpec, AbstractGenome}" href="#Jessamine.run_genome_symbolic-Tuple{GenomeSpec, AbstractGenome}"><code>Jessamine.run_genome_symbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_genome_symbolic(g_spec, genome; paramter_sym=:p, input_sym=:x)</code></pre><p>Build a symbolic form for the output of the final time step of running <code>genome</code>.  The parameter vector and input vector are <code>Symbolics</code> objects of the form <code>p[j]</code> and <code>x[j]</code>.  The variable names can be specified with the keyword arguments.</p><p>Return a named tuple <code>(p, x, z)</code> where <code>p</code> and <code>x</code>, are vectors of <code>Symbolics</code> objects used to represent genome parameters and inputs; and <code>w</code> is a vector of genome outputs in symbolic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/SymbolicForm.jl#L52-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.short_show-Tuple{Any}" href="#Jessamine.short_show-Tuple{Any}"><code>Jessamine.short_show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">short_show([io::IO], x)</code></pre><p>Print a short version of <code>x</code> to <code>io</code>, using <code>stdout</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.show_symbolic-Tuple{GenomeSpec, Genome}" href="#Jessamine.show_symbolic-Tuple{GenomeSpec, Genome}"><code>Jessamine.show_symbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_symbolic(g_spec, genome; output_sym, scratch_sym, parameter_sym, input_sym)</code></pre><p>Return a matrix with three columns. The first is row indices 1, 2, etc. The second is the inital worspace vector in symbolic form. The third is the future workspace state in symbolic form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/SymbolicForm.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.show_symbolic-Tuple{NamedTuple}" href="#Jessamine.show_symbolic-Tuple{NamedTuple}"><code>Jessamine.show_symbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_symbolic(fit_result::NamedTuple; kw_args...)</code></pre><p>Call <code>show_symbolic</code> with the <code>g_spec::GenomeSpec</code> and <code>best_agent.genome::AbstractGenome</code> found in <code>fit_result</code>. Return the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L468-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.splat_or_default-Tuple{Any, Any, Any}" href="#Jessamine.splat_or_default-Tuple{Any, Any, Any}"><code>Jessamine.splat_or_default</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splat_or_default(op, def, operands)</code></pre><p>Return the result of applying <code>op</code> to the operands, with <code>op([]) = def</code> and <code>op([x1...]) = op(x1...)</code>. The <code>Base.splat</code> function doesn&#39;t have a way to deal with the first case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Operations.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.vns_keep_going-Tuple{AbstractPopulationCondition}" href="#Jessamine.vns_keep_going-Tuple{AbstractPopulationCondition}"><code>Jessamine.vns_keep_going</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vns_keep_going(::AbstractPopulationCondition)</code></pre><p>Return whether VNS should continue to another epoch. Utility function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/Evolution.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Jessamine.workspace_size-Tuple{GenomeSpec}" href="#Jessamine.workspace_size-Tuple{GenomeSpec}"><code>Jessamine.workspace_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">workspace_size(g_spec::GenomeSpec)</code></pre><p>Return the number of elements in the workspace vector specified by <code>g_spec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/GenomeCore.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatisticalTraits.supports_weights-Tuple{Type{JessamineDeterministic}}" href="#StatisticalTraits.supports_weights-Tuple{Type{JessamineDeterministic}}"><code>StatisticalTraits.supports_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">supports_weights(::Type{JessamineModel})</code></pre><p>Return <code>true</code>.  A Jessamine model supports weight vectors for training data <em>if</em> the inner model does.  Since MLJ determines this at the type level, it has to return <code>true</code> here to allow a weight vector to be passed in.  The <code>fit</code> implementation throws an exception if a non-<code>nothing</code> weight vector is passed in and the inner model does not allow a weight vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L229-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatisticalTraits.supports_weights-Tuple{Type{JessamineProbabilistic}}" href="#StatisticalTraits.supports_weights-Tuple{Type{JessamineProbabilistic}}"><code>StatisticalTraits.supports_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">supports_weights(::Type{JessamineModel})</code></pre><p>Return <code>true</code>.  A Jessamine model supports weight vectors for training data <em>if</em> the inner model does.  Since MLJ determines this at the type level, it has to return <code>true</code> here to allow a weight vector to be passed in.  The <code>fit</code> implementation throws an exception if a non-<code>nothing</code> weight vector is passed in and the inner model does not allow a weight vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wgm-applied-math/Jessamine.jl/blob/145840b6b32c7e2fa183becc8adc2bad54b483a3/src/MLJOutside.jl#L243-L252">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Jessamine.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 8 August 2024 22:40">Thursday 8 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
